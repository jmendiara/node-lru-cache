{"name":"serialized-lru-cache","tagline":"A cache object that deletes the least-recently-used items, with serialization support.","body":"# serialized lru cache\r\n\r\nA cache object that deletes the least-recently-used items, with serialization support.\r\n\r\nThis is a fork of the wonderful [@isaacs](https://github.com/isaacs) [node-lru-cache](https://github.com/isaacs/node-lru-cache) with several improvements\r\n * [Serialization support](https://github.com/isaacs/node-lru-cache/pull/40)\r\n * [Bug](https://github.com/isaacs/node-lru-cache/issues/41) [fixes](https://github.com/isaacs/node-lru-cache/issues/33)\r\n * Bower support\r\n\r\n## Install\r\nGet it from [npm](https://www.npmjs.com/)\r\n```sh\r\nnpm install serialized-lru-cache\r\n```\r\n```js\r\nvar LRUCache = require(\"lru-cache\");\r\nvar cache = LRUCache(options);\r\n```\r\n\r\nor from [bower](http://bower.io/)\r\n```sh\r\nbower install serialized-lru-cache\r\n```\r\n```html\r\n<script type=\"text/javascript\" src=\"bower_components/serialized-lru-cache/lib/lru-cache.js\"></script>\r\n<script type=\"text/javascript\">\r\n  var cache = window.LRUCache(options);\r\n</script>\r\n```\r\n\r\n## Usage:\r\n\r\n```javascript\r\nvar LRU = require(\"lru-cache\")\r\n  , options = { max: 500\r\n              , length: function (n, key) { return n.length * 2 + key.length }\r\n              , dispose: function (key, n) { n.close() }\r\n              , maxAge: 1000 * 60 * 60 }\r\n  , cache = LRU(options)\r\n  , otherCache = LRU(50) // sets just the max size\r\n\r\ncache.set(\"key\", \"value\")\r\ncache.get(\"key\") // \"value\"\r\n\r\ncache.reset()    // empty the cache\r\n```\r\n\r\nIf you put more stuff in it, then items will fall out.\r\n\r\nIf you try to put an oversized thing in it, then it'll fall out right\r\naway.\r\n\r\nYou can save the current cache and load its entries in another cache instantiated with other options \r\n\r\n```javascript\r\nvar LRU = require(\"lru-cache\")\r\n  , fs = require(\"fs\")\r\n  , cache = LRU( {max: 500, maxAge: 60000})\r\n  , otherCache = LRU(50) // sets just the max size\r\n\r\ncache.set(\"key\", \"value\")\r\nfs.writeFileSync(\"dump.json\", JSON.stringify(cache));\r\notherCache.load(require(\"dump.json\"));\r\n```\r\n\r\n## Options\r\n\r\n* `max` The maximum size of the cache, checked by applying the length\r\n  function to all values in the cache.  Not setting this is kind of\r\n  silly, since that's the whole purpose of this lib, but it defaults\r\n  to `Infinity`.\r\n* `maxAge` Maximum age in ms.  Items are not pro-actively pruned out\r\n  as they age, but if you try to get an item that is too old, it'll\r\n  drop it and return undefined instead of giving it to you.\r\n* `length` Function that is used to calculate the length of stored\r\n  items.  If you're storing strings or buffers, then you probably want\r\n  to do something like `function(v, k){return v.length}`.  The default is\r\n  `function(n){return 1}`, which is fine if you want to store `n`\r\n  like-sized things.\r\n* `dispose` Function that is called on items when they are dropped\r\n  from the cache.  This can be handy if you want to close file\r\n  descriptors or do other cleanup tasks when items are no longer\r\n  accessible.  Called with `key, value`.  It's called *before*\r\n  actually removing the item from the internal cache, so if you want\r\n  to immediately put it back in, you'll have to do that in a\r\n  `nextTick` or `setTimeout` callback or it won't do anything.\r\n* `stale` By default, if you set a `maxAge`, it'll only actually pull\r\n  stale items out of the cache when you `get(key)`.  (That is, it's\r\n  not pre-emptively doing a `setTimeout` or anything.)  If you set\r\n  `stale:true`, it'll return the stale value before deleting it.  If\r\n  you don't set this, then it'll return `undefined` when you try to\r\n  get a stale entry, as if it had already been deleted.\r\n\r\n## API\r\n\r\n* `set(key, value)`\r\n* `get(key) => value`\r\n\r\n    Both of these will update the \"recently used\"-ness of the key.\r\n    They do what you think.\r\n\r\n* `peek(key)`\r\n\r\n    Returns the key value (or `undefined` if not found) without\r\n    updating the \"recently used\"-ness of the key.\r\n\r\n    (If you find yourself using this a lot, you *might* be using the\r\n    wrong sort of data structure, but there are some use cases where\r\n    it's handy.)\r\n\r\n* `del(key)`\r\n\r\n    Deletes a key out of the cache.\r\n\r\n* `reset()`\r\n\r\n    Clear the cache entirely, throwing away all values.\r\n\r\n* `has(key)`\r\n\r\n    Check if a key is in the cache, without updating the recent-ness\r\n    or deleting it for being stale.\r\n\r\n* `forEach(function(value,key,cache), [thisp])`\r\n\r\n    Just like `Array.prototype.forEach`.  Iterates over all the keys\r\n    in the cache, in order of recent-ness.  (Ie, more recently used\r\n    items are iterated over first.)\r\n\r\n* `keys()`\r\n\r\n    Return an array of the keys in the cache.\r\n\r\n* `values()`\r\n\r\n    Return an array of the values in the cache.\r\n\r\n* `toJSON()`\r\n\r\n    Return an array of the cache entries ready for serialization.\r\n\r\n* `load(cacheEntriesArray)`\r\n\r\n    Loads another cache entries array, obtained with `sourceCache.toJSON()`, into the cache. The destination cache\r\n    is reset before loading the new entries\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}